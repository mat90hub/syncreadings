# Managing custom events in tkinterhttps://tkdocs.com/tutorial/eventloop.html

## Description of the event_loop in tkinter

Refer to the page of [TkDocs](https://tkdocs.com/tutorial/eventloop.html)

## Explanations on ``event_generate``.

In **Tkinter**, there is no built-in function called generate_event. The event_generate method is used to programmatically generate and
trigger events within a **Tkinter** application. This method is available on most **Tkinter** widgets and is used to simulate user-generated events.

Here's the basic usage of the event_generate method:

```python
widget.event_generate("<<EventName>>")
```

In the code above, you would replace widget with the specific widget you want to generate an event for (e.g., a button, label, or any other widget).``"<<EventName>>"`` should be replaced with the name of the event you want to generate. When this method is called, it simulates the specified event as if it were generated by user interaction.

For example, if you have a button named my_button and you want to programmatically trigger a click event for that button, you can use:

```python
my_button.event_generate("`<Button-1>`")
```

This would simulate a left mouse button click on the button, triggering the button's associated command or event handler as if it were clicked by the user.

The ``event_generate`` method is useful when you want to automate or programmatically trigger events in response to specific conditions or actions within your **Tkinter** application. It allows you to simulate user interactions for testing or other purposes.

The ``event_generate`` method allows you to generate and trigger events on widgets, and the ``when`` argument specifies when the event should be added to the event queue. The ``when`` argument is used to control the order in which events are processed when multiple events are generated in quick succession.

The ``when`` argument can take one of the following values:

- ``now``: This is the default value. It indicates that the event should be added to the  event queue immediately and processed as soon as possible. If multiple events are generated with ``now``, they will be processed in the order they were generated.
- ``tail``: This indicates that the event should be added to the end of the event queue. Events generated with ``tail`` are processed after all other events that were previously added to the queue with ``now``. This is useful if you want to ensure that certain events are processed after others.

The ``when`` argument is typically used when you need precise control over the order in which events are processed, especially in scenarios where you have multiple events being generated and you want to ensure a sinitialisedpecific order of processing.

Here's an example:

```python
my_button.event_generate("<Button-1>", when="tail")
```

In this example, the event generated for my_button with ``tail`` as the when argument will be processed after other events generated with ``now``.

By default, events are generated with ``now``, and they are processed in the order they are generated. If you need to enforce a specific order of event processing, you can use the ``tail`` option.

## Explanations on ``self.event_handler``

In an object, the ``self.event_handler`` typically refers to an instance variable that holds a reference to a function or method that can be called or executed when a specific event or condition occurs within that object. It is a common pattern used to allow **external code** to specify a callback function to be executed within the object when a particular event is triggered.

Here's a typical usage scenario for self.event_handler in an object:

- You define a class that represents an object with specific functionality.
- You want to allow external code to specify custom behavior or actions that should occur when a particular event happens within the object.
- You provide a method, often called something like set_event_handler or bind_event_handler, that takes a function or method as an argument and assigns it to the self.event_handler instance variable.
- When the event or condition of interest occurs within the object, you can call self.event_handler() to execute the specified function or method.

Here's a simplified example to illustrate this concept:

```python
class MyObject:
    def __init__(self, container):
        self.EVENT_HANDLER = None
        self.CONTAINER = container

    def do_something(self):
        # Perform some action
        if self.EVENT_HANDLER is not None:
            self.CONTAINER.event_generate('<customEvent>')
            self.EVANT_HANDLER('Custome Event Generated')

    def set_event_handler(self, handler):
        self.EVENT_HANDLER = handler

# Usage:

my_object = MyObject()

def custom_event_handler():
    print("Custom Event Generated")

my_object.set_event_handler(custom_event_handler)
my_object.do_something()

```


# Calls the custom event handler when do_something is called

In this example:

- The ``MyObject`` class has an ``event_handler`` instance variable that can hold a reference to a function.
- The ``set_event_handler`` method allows you to set the ``event_handler`` to a specific function (defined externally).
- The ``do_something`` method performs an action and, if an event handler is set, it calls the event handler.

By using ``self.event_handler``, you can make your object more flexible and customizable, allowing external code to specify what should happen when certain events or conditions occur within the object. This pattern is often used in various contexts, including GUI programming, event-driven systems, and callback registration.

## examples 1

(in sandbox)

This example in **TkInter** built a button in a tk Window and this button generates a custom event when the button it triggered. The command linked to the button is triggering the function ``generate_custom_event``. This function check if the ``event_handler`` of the object is empty or linked to a function. If it has been linked (externally) to a function, the function ``generate_custom_event`` generate a custom event in the parent widget (so here the main window) and then launch this function on this event.

```python
import tkinter as tk

class MyObject:
    def __init__(self, parent):
        self.parent = parent
        self.label = tk.Label(parent, text="buttons to activate event")
        self.label.pack()
  
        self.button = tk.Button(parent, text="Generate Event", 
                                command=self.generate_custom_event)
        self.button.pack()

        self.event_handler = None

    def generate_custom_event(self):
        if self.event_handler is not None:
            self.parent.event_generate('<<CustomEvent>>', when="tail")
            self.event_handler("Custom Event Generated")

    def set_event_handler(self, handler):
        self.EVENT_HANDLER = handler

# Create the main window
root = tk.Tk()
root.title("Custom Object Example")

# Create an instance of your custom object
my_obj = MyObject(root)

# Function to handle the custom event
def custom_event_handler(event):
    print(event)

# Set the event handler for the custom object
my_obj.set_event_handler(custom_event_handler)

# Start the main loop
root.mainloop()
```

## examples 2

(in sandbox)

This example is continuing on the same base of the preceding, but is now issuing an event of writing and an event of clearing a message. IT is used afterward to give indication in a status bar. In the object, the events are only separated in two: the one which is ordering to write and the one ordering to clear the message. The main program decide that this message should be here in the status bar, it has created.

```python
evenimport tkinter as tk

class MyObject:
    def __init__(self, parent, label_text):
        self.parent = parent
        self.label = tk.Label(parent, text=label_text)
        self.label.pack(padx=20)
  
        self.button = tk.Button(parent, text="write in status bar", 
                                command=self.generate_write_event)
        self.button.pack(padx=20, pady=10)

        self.button = tk.Button(parent, text="clear status bar", 
                                command=self.generate_clear_event)
        self.button.pack(padx=20, pady=10)

        self.event_handler = None

    def generate_write_event(self):
        if self.event_handler is not None:
            self.parent.event_generate("<<writeEvent>>", when="tail")
            self.event_handler("Write Event Generated")

    def generate_clear_event(self):
        if self.event_handler is not None:
            self.parent.event_generate("<<clearEvent>>", when="tail")
            self.event_handler("Clear Event Generated")

    def set_event_handler(self, handler):
        self.event_handler = handler

# Create the main window
root = tk.Tk()
root.title("Custom Object Example")

frame = tk.Frame(root, height=3, bg="yellow")
frame.pack(fill=tk.BOTH, expand=True)
my_obj = MyObject(frame, label_text="Button to write in the status bar")

frame2 = tk.Frame(root, height=2)
frame2.pack(fill=tk.BOTH, expand=False, side=tk.BOTTOM)

status_lbl = tk.Label(frame2, text="status:")
status_lbl.pack(side=tk.LEFT, anchor="w", fill=tk.BOTH)

# Function to handle the custom event
def custom_event_handler(event):
    if event == "Write Event Generated":
        status_lbl.configure(text="status: button clicked")
    if event == "Clear Event Generated":
        status_lbl.configure(text="status:")

# Set the event handler for the custom object
my_obj.set_event_handler(custom_event_handler)

# Start the main loop
root.mainloop()
```
